{"version":3,"sources":["webpack:///path---blog-2020-02-01-reflections-on-documenting-using-the-openapi-spec-20a321bf1c1c1d083e98.js","webpack:///./.cache/json/blog-2020-02-01-reflections-on-documenting-using-the-openapi-spec.json"],"names":["webpackJsonp","925","module","exports","data","markdownRemark","html","frontmatter","date","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,i5LAA2vDC,aAA4qIC,KAAA,4BAAAC,KAAA,qEAAAC,MAAA,uDAA6KC","file":"path---blog-2020-02-01-reflections-on-documenting-using-the-openapi-spec-20a321bf1c1c1d083e98.js","sourcesContent":["webpackJsonp([215212237283349],{\n\n/***/ 925:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>Swagger started life as an offering from <a href=\\\"https://swagger.io/solutions/getting-started-with-oas/\\\">SmartBear</a>. SmartBear then donated the API specification to the Open Source community, where it was re-branded <code>OpenAPI 2.0</code> ... There now exists the <code>OpenAPI 3.0</code> specification [and I go through a bit of pain to generate this automatically, as <code>Springfox</code> support for <code>OpenAPI 3.0</code> hasn't yet come out of experimental channels]. <em>[I]s it really worth doing all this for the sake of documentation?</em> <strong>[Y]es</strong>, it is worth the effort.</p>\\n</blockquote>\\n<p>I have <a href=\\\"./2019-03-14_on-apis-swagger-or-stumble\\\">talked before</a> about Swagger at a high level, but let's now back up a bit and re-visit.</p>\\n<p>Swagger, a SmartBear product, came out and allowed people to annotate code. These annotations would be parsed and transformed into a JSON file that described the API and its endpoints, expected data, and so forth.</p>\\n<p>Things were not-terrible, life was good, annotations aren't terribly bad, right?</p>\\n<p>I spent most of 2019 working professionally in <code>Spring Boot 2.x</code>. Spring Boot is an opinionated library built atop <code>Spring</code>, which itself runs atop <code>Java</code>. The short version is that components can be wired together very quickly, and different component types can be built and orchestrated, and Spring will ultimately take these components, parse them as Beans, and vomit the whole thing out as a bunch of connected POJOs (Plain Old Java Objects). It's pretty good times.</p>\\n<p>All that Spring and Spring Boot require to work this magic is</p>\\n<ol>\\n<li>Conformance to an established convention (AOP and IoC are at work here);</li>\\n<li>[Extensive] use of annotations.</li>\\n</ol>\\n<p><strong>Annotations</strong>. My God, so many annotations. Annotations <em>everywhere</em>. As a relative newcomer, I know (and love) the annotations that I work with, but also as a relative newcomer to the libraries, it's a bit overwhelming. I also like to pull in <a href=\\\"https://beanvalidation.org/2.0/\\\">JSR-380 (bean validation)</a>, so I can trade stand-alone Java validators for annotations in model classes.</p>\\n<p>Is life good here? Well, yes, but it's <em>noisy</em>.</p>\\n<p>And in comes Swagger, riding atop its own ocean of annotations.</p>\\n<p>I've thus far given you half the story about Swagger. Swagger started life as an offering from <a href=\\\"https://swagger.io/solutions/getting-started-with-oas/\\\">SmartBear</a>. SmartBear then donated the API specification to the Open Source community, where it was re-branded <code>OpenAPI 2.0</code>. <em>OpenAPI 2.0 and Swagger specification are, for now, the same thing</em>. These terms can be used interchangeably. If you've ever clicked-through a <code>Swagger UI</code> screen and looked at <code>/v2/api-docs</code> and seen the resulting <code>JSON</code> file, you have seen OpenAPI 2.0 specification code. There now exists the <code>OpenAPI 3.0</code> specification, but there's no good way to get there from Spring Boot. Lately, though, I've been mutating OpenAPI 2.0 spec (manually, with the <code>sed</code>, <code>grep</code>, and <code>jq</code> CLI tools) and generating <code>OpenAPI 3.0</code> JSON output, which I then send to <a href=\\\"https://github.com/Redocly/redoc\\\"><code>Redoc</code></a> for compilation into a static HTML file (this is quasi-public facing, so I wanted this output to be fast, immutable, and not live on the application server). <code>OpenAPI 3.0</code> specification improves upon Swagger by--in addition to other items--permitting multiple servers to be listed for an API (e.g. <code>dev</code>, <code>qa</code>, <code>staging</code>, <code>production</code>), along with labels for each, versus presenting one and only one server. Support for OpenAPI 3.0 generation via Springfox isn't yet ready, so for now, I'm left doing the 2.0 -> 3.0 conversion dance in the console.</p>\\n<p>It sometimes feels a bit much, and it's easy to ask the question, <em>is it really worth doing all this for the sake of documentation?</em></p>\\n<p>I stand fast in my earlier blog entry that, <strong>yes</strong>, it is worth the effort. Good software engineers do, in my considered opinion, work harder to ease and facilitate consumption and comprehension of the code they write. In other words, as the code we can consistently and correctly generate becomes more complex and intricate, so too must we be mindful and work to make it easier to consume this code.</p>\\n<p>These days, I tend to use Springfox to parse Swagger annotations and build the <code>api-doc.json</code> description. As described above, converting this <code>OpenAPI 2.0</code> specification file to <code>OpenAPI 3.0</code> specification takes a bit of extra-IDE work, and I look forward to seeing this requirement go away as <code>Springfox</code> becomes able to generate <code>OpenAPI 3.0</code> specifications directly. However, as Springfox also provides a bean validation plugin, I can quickly annotate these classes and let a consumer of the documentation know <em>exactly</em> what I'm expecting to see in the data they will pass. This eliminates the tedious task of reaching out to consumers and telling them, \\\"attribute X on this model now cannot be <code>null</code>,\\\" or support emails shuttled back and forth for a missing attribute that we've both missed. In other words, these annotations allow me to better-help consumers of my software, and allow consumers to better-help <em>themselves</em>, and <em>on their schedule</em>.</p>\\n<p>As a collective group, software engineers are disinclined to generate high-quality and <em>current</em> documentation. We are nearly to the point where the \\\"this is too cumbersome to maintain\\\" argument vanishes, and only moderate measures of discipline and compassion remain as impediments to providing high-quality and maintained documentation. I look forward to this day.</p>\",\"frontmatter\":{\"date\":\"2020-02-01T13:15:00-07:00\",\"path\":\"/blog/2020-02-01_reflections-on-documenting-using-the-openapi-spec\",\"title\":\"Reflections on Documenting Using the OpenAPI Spec\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-2020-02-01-reflections-on-documenting-using-the-openapi-spec-20a321bf1c1c1d083e98.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>Swagger started life as an offering from <a href=\\\"https://swagger.io/solutions/getting-started-with-oas/\\\">SmartBear</a>. SmartBear then donated the API specification to the Open Source community, where it was re-branded <code>OpenAPI 2.0</code> ... There now exists the <code>OpenAPI 3.0</code> specification [and I go through a bit of pain to generate this automatically, as <code>Springfox</code> support for <code>OpenAPI 3.0</code> hasn't yet come out of experimental channels]. <em>[I]s it really worth doing all this for the sake of documentation?</em> <strong>[Y]es</strong>, it is worth the effort.</p>\\n</blockquote>\\n<p>I have <a href=\\\"./2019-03-14_on-apis-swagger-or-stumble\\\">talked before</a> about Swagger at a high level, but let's now back up a bit and re-visit.</p>\\n<p>Swagger, a SmartBear product, came out and allowed people to annotate code. These annotations would be parsed and transformed into a JSON file that described the API and its endpoints, expected data, and so forth.</p>\\n<p>Things were not-terrible, life was good, annotations aren't terribly bad, right?</p>\\n<p>I spent most of 2019 working professionally in <code>Spring Boot 2.x</code>. Spring Boot is an opinionated library built atop <code>Spring</code>, which itself runs atop <code>Java</code>. The short version is that components can be wired together very quickly, and different component types can be built and orchestrated, and Spring will ultimately take these components, parse them as Beans, and vomit the whole thing out as a bunch of connected POJOs (Plain Old Java Objects). It's pretty good times.</p>\\n<p>All that Spring and Spring Boot require to work this magic is</p>\\n<ol>\\n<li>Conformance to an established convention (AOP and IoC are at work here);</li>\\n<li>[Extensive] use of annotations.</li>\\n</ol>\\n<p><strong>Annotations</strong>. My God, so many annotations. Annotations <em>everywhere</em>. As a relative newcomer, I know (and love) the annotations that I work with, but also as a relative newcomer to the libraries, it's a bit overwhelming. I also like to pull in <a href=\\\"https://beanvalidation.org/2.0/\\\">JSR-380 (bean validation)</a>, so I can trade stand-alone Java validators for annotations in model classes.</p>\\n<p>Is life good here? Well, yes, but it's <em>noisy</em>.</p>\\n<p>And in comes Swagger, riding atop its own ocean of annotations.</p>\\n<p>I've thus far given you half the story about Swagger. Swagger started life as an offering from <a href=\\\"https://swagger.io/solutions/getting-started-with-oas/\\\">SmartBear</a>. SmartBear then donated the API specification to the Open Source community, where it was re-branded <code>OpenAPI 2.0</code>. <em>OpenAPI 2.0 and Swagger specification are, for now, the same thing</em>. These terms can be used interchangeably. If you've ever clicked-through a <code>Swagger UI</code> screen and looked at <code>/v2/api-docs</code> and seen the resulting <code>JSON</code> file, you have seen OpenAPI 2.0 specification code. There now exists the <code>OpenAPI 3.0</code> specification, but there's no good way to get there from Spring Boot. Lately, though, I've been mutating OpenAPI 2.0 spec (manually, with the <code>sed</code>, <code>grep</code>, and <code>jq</code> CLI tools) and generating <code>OpenAPI 3.0</code> JSON output, which I then send to <a href=\\\"https://github.com/Redocly/redoc\\\"><code>Redoc</code></a> for compilation into a static HTML file (this is quasi-public facing, so I wanted this output to be fast, immutable, and not live on the application server). <code>OpenAPI 3.0</code> specification improves upon Swagger by--in addition to other items--permitting multiple servers to be listed for an API (e.g. <code>dev</code>, <code>qa</code>, <code>staging</code>, <code>production</code>), along with labels for each, versus presenting one and only one server. Support for OpenAPI 3.0 generation via Springfox isn't yet ready, so for now, I'm left doing the 2.0 -> 3.0 conversion dance in the console.</p>\\n<p>It sometimes feels a bit much, and it's easy to ask the question, <em>is it really worth doing all this for the sake of documentation?</em></p>\\n<p>I stand fast in my earlier blog entry that, <strong>yes</strong>, it is worth the effort. Good software engineers do, in my considered opinion, work harder to ease and facilitate consumption and comprehension of the code they write. In other words, as the code we can consistently and correctly generate becomes more complex and intricate, so too must we be mindful and work to make it easier to consume this code.</p>\\n<p>These days, I tend to use Springfox to parse Swagger annotations and build the <code>api-doc.json</code> description. As described above, converting this <code>OpenAPI 2.0</code> specification file to <code>OpenAPI 3.0</code> specification takes a bit of extra-IDE work, and I look forward to seeing this requirement go away as <code>Springfox</code> becomes able to generate <code>OpenAPI 3.0</code> specifications directly. However, as Springfox also provides a bean validation plugin, I can quickly annotate these classes and let a consumer of the documentation know <em>exactly</em> what I'm expecting to see in the data they will pass. This eliminates the tedious task of reaching out to consumers and telling them, \\\"attribute X on this model now cannot be <code>null</code>,\\\" or support emails shuttled back and forth for a missing attribute that we've both missed. In other words, these annotations allow me to better-help consumers of my software, and allow consumers to better-help <em>themselves</em>, and <em>on their schedule</em>.</p>\\n<p>As a collective group, software engineers are disinclined to generate high-quality and <em>current</em> documentation. We are nearly to the point where the \\\"this is too cumbersome to maintain\\\" argument vanishes, and only moderate measures of discipline and compassion remain as impediments to providing high-quality and maintained documentation. I look forward to this day.</p>\",\"frontmatter\":{\"date\":\"2020-02-01T13:15:00-07:00\",\"path\":\"/blog/2020-02-01_reflections-on-documenting-using-the-openapi-spec\",\"title\":\"Reflections on Documenting Using the OpenAPI Spec\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-2020-02-01-reflections-on-documenting-using-the-openapi-spec.json\n// module id = 925\n// module chunks = 215212237283349"],"sourceRoot":""}